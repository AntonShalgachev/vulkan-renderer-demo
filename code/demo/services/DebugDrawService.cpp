#include "DebugDrawService.h"

#include "vkgfx/ResourceManager.h"
#include "vkgfx/Renderer.h"
#include "vkgfx/BufferMetadata.h"
#include "vkgfx/Mesh.h"
#include "vkgfx/PipelineKey.h"

#include "ShaderPackage.h"

#include "wrapper/ShaderModule.h" // TODO remove, used only for enum

#include <vector>
#include <fstream>

namespace
{
    // normals: offset 0, stride 24, type vec3, count 24
    // position: offset 12, stride 24, type vec3, count 24
    // indices: offset 576, type unsigned short, count 36
    static std::vector<unsigned char> const boxBuffer = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0xbf,
        0x00, 0x00, 0x00, 0xbf, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0xbf, 0x00, 0x00, 0x00, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0xbf,
        0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xbf, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f,
        0x00, 0x00, 0x00, 0xbf, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xbf,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbf, 0x00, 0x00, 0x00, 0xbf, 0x00, 0x00, 0x00, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xbf, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f,
        0x00, 0x00, 0x00, 0xbf, 0x00, 0x00, 0x00, 0xbf, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xbf,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbf, 0x00, 0x00, 0x00, 0xbf, 0x00, 0x00, 0x00, 0xbf,
        0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f,
        0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0xbf, 0x00, 0x00, 0x00, 0x3f,
        0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f,
        0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0xbf, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0xbf, 0x00, 0x00, 0x00, 0xbf,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbf,
        0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbf,
        0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0xbf, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0xbf,
        0x00, 0x00, 0x80, 0xbf, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbf,
        0x00, 0x00, 0x00, 0xbf, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x80, 0xbf, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbf, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x3f,
        0x00, 0x00, 0x80, 0xbf, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbf,
        0x00, 0x00, 0x00, 0xbf, 0x00, 0x00, 0x00, 0xbf, 0x00, 0x00, 0x80, 0xbf, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbf, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0xbf,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xbf, 0x00, 0x00, 0x00, 0xbf,
        0x00, 0x00, 0x00, 0xbf, 0x00, 0x00, 0x00, 0xbf, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x80, 0xbf, 0x00, 0x00, 0x00, 0xbf, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0xbf,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xbf, 0x00, 0x00, 0x00, 0x3f,
        0x00, 0x00, 0x00, 0xbf, 0x00, 0x00, 0x00, 0xbf, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x80, 0xbf, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0xbf,
        0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04, 0x00, 0x05, 0x00,
        0x06, 0x00, 0x07, 0x00, 0x06, 0x00, 0x05, 0x00, 0x08, 0x00, 0x09, 0x00, 0x0a, 0x00, 0x0b, 0x00,
        0x0a, 0x00, 0x09, 0x00, 0x0c, 0x00, 0x0d, 0x00, 0x0e, 0x00, 0x0f, 0x00, 0x0e, 0x00, 0x0d, 0x00,
        0x10, 0x00, 0x11, 0x00, 0x12, 0x00, 0x13, 0x00, 0x12, 0x00, 0x11, 0x00, 0x14, 0x00, 0x15, 0x00,
        0x16, 0x00, 0x17, 0x00, 0x16, 0x00, 0x15, 0x00
    };

    // TODO remove duplication with DemoApplication
    std::vector<unsigned char> readFile(const std::string& filename)
    {
        std::ifstream file(filename, std::ios::ate | std::ios::binary);

        if (!file.is_open())
            throw std::runtime_error("failed to open file!");

        std::streamsize fileSize = file.tellg();
        std::vector<unsigned char> buffer(static_cast<std::size_t>(fileSize));

        file.seekg(0);
        file.read(reinterpret_cast<char*>(buffer.data()), fileSize); // safe, since char and unsigned char have the same alignment and representation
        file.close();

        return buffer;
    }
}

DebugDrawService::DebugDrawService(Services& services) : ServiceContainer(services)
{
    
}

DebugDrawService::~DebugDrawService() = default;

void DebugDrawService::init(vkgfx::Renderer& renderer)
{
    vkgfx::ResourceManager& resources = renderer.getResourceManager();

    {
        vkgfx::BufferMetadata metadata{
        .usage = vkgfx::BufferUsage::VertexIndexBuffer,
        .location = vkgfx::BufferLocation::DeviceLocal,
        .isMutable = false,
        };
        m_buffer = resources.createBuffer(boxBuffer.size(), metadata);
        resources.uploadBuffer(m_buffer, boxBuffer);
    }

    {
        vkgfx::Mesh mesh = {
            .vertexBuffers = {{m_buffer, 0}},
            .indexBuffer = {m_buffer, 576},
            .indexCount = 36,
            .indexType = vkgfx::IndexType::UnsignedShort,
            .indexOffset = 0,
            .vertexOffset = 0,
        };

        m_mesh = resources.createMesh(std::move(mesh));
    }

    vkgfx::ShaderModuleHandle vertexShaderModule;
    vkgfx::ShaderModuleHandle fragmentShaderModule;
    
    // TODO remove duplication in DemoApplication::createUIResources
    {
        vkr::ShaderPackage package{ "data/shaders/packaged/debugdraw.vert" };
        std::string const* path = package.get({});
        assert(path);
        if (path)
            vertexShaderModule = resources.createShaderModule(readFile(*path), vko::ShaderModuleType::Vertex, "main");
    }

    {
        vkr::ShaderPackage package{ "data/shaders/packaged/debugdraw.frag" };
        std::string const* path = package.get({});
        assert(path);
        if (path)
            fragmentShaderModule = resources.createShaderModule(readFile(*path), vko::ShaderModuleType::Fragment, "main");
    }

    {
        vkgfx::PipelineKey key;
        key.shaderHandles = { vertexShaderModule, fragmentShaderModule };
        key.uniformConfigs = {
            // TODO remove unnecessary configs
            vkgfx::UniformConfiguration{
                .hasBuffer = true,
                .hasAlbedoTexture = false,
                .hasNormalMap = false,
            },
            vkgfx::UniformConfiguration{
                .hasBuffer = false,
                .hasAlbedoTexture = false,
                .hasNormalMap = false,
            },
            vkgfx::UniformConfiguration{
                .hasBuffer = false,
                .hasAlbedoTexture = false,
                .hasNormalMap = false,
            },
        };
        key.vertexConfig = {
            .bindings = {
                vkgfx::VertexConfiguration::Binding{
                    .stride = 24,
                },
            },
            .attributes = {
                vkgfx::VertexConfiguration::Attribute{
                    .binding = 0,
                    .location = 0,
                    .offset = 12,
                    .type = vkgfx::AttributeType::Vec3f,
                },
                vkgfx::VertexConfiguration::Attribute{
                    .binding = 0,
                    .location = 1,
                    .offset = 0,
                    .type = vkgfx::AttributeType::Vec3f,
                },
            },
            .topology = vkgfx::VertexTopology::Triangles,
        };
        key.renderConfig = {
            .cullBackfaces = false,
            .wireframe = true,
            .depthTest = true,
            .alphaBlending = false,
        };
        key.pushConstantRanges = {
            vkgfx::PushConstantRange{
                .offset = 0,
                .size = sizeof(glm::mat4),
            },
        };

        m_pipeline = resources.getOrCreatePipeline(std::move(key));
    }
}

void DebugDrawService::sphere(glm::vec3 const& center, glm::vec3 const& scale, glm::vec3 const& color, float duration)
{

}

void DebugDrawService::box(glm::vec3 const& center, glm::quat const& rotation, glm::vec3 const& scale, glm::vec3 const& color, float duration)
{
    auto matrix = glm::identity<glm::mat4>();

    matrix = glm::translate(matrix, center);
    matrix = matrix * glm::mat4_cast(rotation);
    matrix = glm::scale(matrix, scale);

    std::vector<unsigned char> pushConstants;
    pushConstants.resize(sizeof(matrix));
    memcpy(pushConstants.data(), &matrix, sizeof(matrix));

    vkgfx::TestObject& object = m_objects.emplace_back();
    object.pipeline = m_pipeline;
    object.mesh = m_mesh;
    object.pushConstants = std::move(pushConstants);
}

void DebugDrawService::draw(vkgfx::Renderer& renderer)
{
    for (auto&& object : m_objects)
        renderer.addOneFrameTestObject(std::move(object));
    m_objects.clear();
}
